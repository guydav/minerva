import argparse
import collections
import os
import time
import itertools
import tqdm
import bisect


DATE_AND_TIME_FORMAT = '%Y_%m_%d_%H_%M_%S'
DEFAULT_MINIMUM_SIZE = 3
DEFAULT_OUTPUT_FILE_TEMPLATE = 'supermarket_optimizer_output_{time}.dat'


class SupermarketOptimizer(object):
    def __init__(self, min_group_size):
        self.min_group_size = min_group_size
        self.occurrence_table = collections.defaultdict(int)
        self.groups_by_size = collections.defaultdict(list)

    def process_input(self, input_file, assume_unsorted=False):
        """
        TODO: document
        :param input_file: an open Python file object, or any other iterable
            whose iteration returns strings representing transactions
        :param assume_unsorted: by default False, should we assume each line
            in the input file is unsorted, and hence, sort it
        :return: None; input file contents processed into optimizer
        """
        for line in input_file:
            group = line.strip().split(' ')
            group_size = len(group)

            if len(group) < self.min_group_size:
                continue

            if assume_unsorted:
                group = sorted(group)

            group = tuple(group)

            self.occurrence_table[group] += 1
            self.groups_by_size[group_size].append(group)

    def _output(self, group, group_count, output_file):
        """
        TODO: document
        :param group:
        :param group_count:
        :param output_file:
        :return:
        """
        output = [str(len(group)), str(group_count)]
        output.extend(group)
        output_file.write(', '.join(output) + '\r\n')

    def _break_down_group(self, group, group_count, sorted_group_lengths):
        start_index = bisect.bisect_left(sorted_group_lengths, len(group)) - 1
        group_set = set(group)

        for subgroup_length in sorted_group_lengths[start_index::-1]:
            for subgroup in self.groups_by_size[subgroup_length]:
                subgroup_set = set(subgroup)

                if subgroup_set.issubset(group_set):
                    self.occurrence_table[subgroup] += group_count

                    remainder_group = tuple(group_set.difference(subgroup_set))

                    if len(remainder_group) < self.min_group_size:
                        return

                    if remainder_group in self.occurrence_table:
                        self.occurrence_table[remainder_group] += group_count
                    else:
                        self._break_down_group(remainder_group, group_count,
                                               sorted_group_lengths)


    def find_supported_groups(self, support_level, output_file):
        """
        TODO: document
        :param support_level:
        :param min_group_size:
        :param output_file:
        :return:
        """
        sorted_group_lengths = list(sorted(self.groups_by_size.keys()))

        for group_length in tqdm.tqdm(sorted_group_lengths[::-1],
                                      total=len(self.occurrence_table)):

            for group in self.groups_by_size[group_length]:
                group_count = self.occurrence_table[group]

                if group_count >= support_level:
                    self._output(group, group_count, output_file)

                else:
                    self._break_down_group(group, group_count,
                                           sorted_group_lengths)

        output_file.flush()


def generate_output_file_path():
    """
    TODO: document
    :param support_level:
    :return:
    """
    return os.path.join(os.curdir, DEFAULT_OUTPUT_FILE_TEMPLATE.format(
        time=time.strftime(DATE_AND_TIME_FORMAT)))


def positive_integer_type(value):
    """
    TODO: document
    :param value:
    :return:
    """
    try:
        int_value = int(value)

    except ValueError:
        raise argparse.ArgumentTypeError(
            'Must be a valid integer, received {value}'.format(value=value))

    if 0 >= int_value:
        raise argparse.ArgumentTypeError(
            'Must be a positive integer, received {value}'.format(value=value))

    return int_value


def main():
    """
    TODO: document
    :return:
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input-file', required=True,
                        type=argparse.FileType('r'),
                        help='Input file - the transaction database')
    parser.add_argument('-o', '--output-file', required=False,
                        default=generate_output_file_path(),
                        help='Output file path - autogenerated if not provided')
    parser.add_argument('-s', '--support-level', required=True,
                        type=positive_integer_type,
                        help='The requisite support level - a positive integer')
    parser.add_argument('-u', '--assume-unsorted', required=False,
                        action='store_true',
                        help='Assume each line in the input file is unsorted')
    parser.add_argument('-g', '--group-size', required=False,
                        default=DEFAULT_MINIMUM_SIZE,
                        help='Override the default minimum group size {size}'
                            .format(size=DEFAULT_MINIMUM_SIZE))

    args = parser.parse_args()
    optimizer = SupermarketOptimizer(args.group_size)
    optimizer.process_input(args.input_file, args.assume_unsorted)
    with open(args.output_file, 'w') as output_file:
        optimizer.find_supported_groups(args.support_level, output_file)

if __name__ == '__main__':
    main()